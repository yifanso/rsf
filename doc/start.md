#从零到一手写基于Redis的分布式锁框架

##分布式锁缘由

* 学习编程初期，我们做的诸如教务系统、成绩管理系统大多是单机架构，
  单机架构在处理并发的问题上一般是依赖于JDK内置的并发编程类库，
  如synchronize关键字、Lock类等。随着业务以及需求的提高，
  单机架构不再满足我们的要求，这个时候我们不免要进行业务上的分离，
  例如基于Maven进行多模块开发。业务与业务分离之后，
  遇到的首要问题就是业务之间如何进行通信，相信会有不少读者了解
  诸如Dubbo、SpringCloud之类的RPC框架，但这些RPC框架并没有
  自带处理分布式并发问题的功能，所以，分布式并发问题还需要我们自己去实现分布式锁。
  
##分布式锁条件
* 为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：

    1. 互斥性。在任意时刻，只有一个客户端能持有锁。
    2. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
    3. 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。 
   解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。
       
##分布式锁的实现方式
分布式锁一般有三种实现方式：
    1.数据库乐观锁
    2.基于Redis的分布式锁
    3.基于Zookeeper的分布式锁
* 3.1 数据库乐观锁
数据库乐观锁的实现方式是先使用SELECT语句查询某字段的值（版本号），该字段即理解为要获取的分布式锁。然后在使用UPDATE语句对正常业务数据进行更新，在UPDATE语句执行时一定要用WHERE条件对版本号进行判断，若版本号在这段时间内并没有发生变化则该语句默认执行成功，否则循环执行即可。


* 3.2 基于Zookeeper的分布式锁
基于Zookeeper实现分布式锁的算法思路大致如下假设锁空间的根节点为/lock：
客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。
客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁。
执行业务代码。
完成业务流程后，删除对应的子节点释放锁。
* 3.3 基于Redis的分布式锁
基于Redis的分布式锁实现是基于Redis自带的 setnx 命令。该命令只有在要设置的字段不存在的情况下才能设置成功，也就是获得分布式锁，否则失败。为了防止客户端异常导致的锁未释放问题，还需要对该字段设置过期时间。

---
本文将基于Redis分布式锁的实现思路设计一个spring-boot-starter-redis-lock框架。
执行上面的setIfAbsent()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。
回顾上面提到的分布式锁的四个条件，在任意时刻，该代码都能保证只有一个客户端能持有锁，并且每一个分布式锁都加了过期时间，保证不会出现死锁，容错性暂时不考虑的话，加锁和解锁通过key保证了对多个客户端而言都是同一把锁，value的作用则是保证对同一把锁的加锁和解锁操作都是同一个客户端。
